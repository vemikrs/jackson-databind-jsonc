/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java library project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.10.2/userguide/building_java_projects.html in the Gradle documentation.
 */

import java.util.Base64

plugins {
    `java-library`
    `maven-publish`
    signing
    id("com.vanniktech.maven.publish")
}

group = "jp.vemi"
// Resolve version with fallbacks:
// 1) Environment variable PROJECT_VERSION (for CI or ad-hoc builds)
// 2) Gradle property "version" (from gradle.properties or -Pversion=...)
// 3) Safe default to avoid "unspecified" artifacts
run {
    val envVersion = System.getenv("PROJECT_VERSION")?.trim().orEmpty()
    val propVersion = findProperty("version")?.toString()?.trim().orEmpty()
    version = when {
        envVersion.isNotEmpty() -> envVersion
        propVersion.isNotEmpty() -> propVersion
        else -> "0.0.0-SNAPSHOT"
    }
}

// Configure Vanniktech Maven Publish Plugin for Central Portal
mavenPublishing {
    publishToMavenCentral(com.vanniktech.maven.publish.SonatypeHost.CENTRAL_PORTAL)
    
    // Only sign if credentials are available
    val hasSigningKey = System.getenv("ORG_GRADLE_PROJECT_signingInMemoryKey") != null
        || System.getenv("GPG_PRIVATE_KEY") != null
        || System.getenv("SIGNING_SECRET_KEY") != null
    
    if (hasSigningKey) {
        signAllPublications()
    }
    
    coordinates("jp.vemi", "jackson-databind-jsonc", version.toString())
    
    pom {
        name.set("Jackson-Databind-Jsonc")
        description.set("A Java library that extends Jackson's JsonMapper to handle JSONC (JSON with Comments) format")
        url.set("https://github.com/vemikrs/jackson-databind-jsonc")
        
        licenses {
            license {
                name.set("Apache License 2.0")
                url.set("https://www.apache.org/licenses/LICENSE-2.0")
            }
        }
        
        developers {
            developer {
                id.set("vemikrs")
                name.set("vemikrs")
                url.set("https://github.com/vemikrs")
            }
        }
        
        scm {
            connection.set("scm:git:git://github.com/vemikrs/jackson-databind-jsonc.git")
            developerConnection.set("scm:git:ssh://github.com:vemikrs/jackson-databind-jsonc.git")
            url.set("https://github.com/vemikrs/jackson-databind-jsonc")
        }
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // Jackson依存
    implementation("com.fasterxml.jackson.core:jackson-databind:2.20.0")

    // Additional dependencies for enhanced functionality
    api(libs.commons.math3)
    implementation(libs.guava)

    // テスト依存
    testImplementation(libs.junit.jupiter)
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
    // Target Java 8 bytecode while building with Java 21 toolchain
    // Prefer --release 8 via compiler args to avoid obsolete source/target warnings
    
    // Note: Vanniktech plugin automatically generates sources and javadoc JARs for Maven Central
    // No need for withSourcesJar() and withJavadocJar() here
}

tasks {
    // Slim JAR（デフォルト・推奨）- 依存関係を含まない軽量版
    jar {
        archiveClassifier.set("")
        archiveFileName.set("jackson-databind-jsonc-${project.version}.jar")
        manifest {
            attributes(mapOf(
                "Implementation-Title" to "jackson-databind-jsonc",
                "Implementation-Version" to project.version,
                "Automatic-Module-Name" to "jp.vemi.jsoncmapper",
                "Multi-Release" to "true"
            ))
        }
    }
    
    // Fat JAR（推奨）- Jackson関連のみ含む最小限の自己完結型
    val fatJar = register<Jar>("fatJar") {
        archiveClassifier.set("all")
        archiveFileName.set("jackson-databind-jsonc-${project.version}-all.jar")
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        
        from(sourceSets.main.get().output)
        
        // Jackson関連のみ含める（Guava, Commons-Mathは除外）
        from({
            configurations.runtimeClasspath.get()
                .filter { it.name.contains("jackson") && it.name.endsWith("jar") }
                .map { zipTree(it) }
        }) {
            exclude("META-INF/*.SF")
            exclude("META-INF/*.DSA")
            exclude("META-INF/*.RSA")
            exclude("META-INF/DEPENDENCIES")
            exclude("META-INF/LICENSE*")
            exclude("META-INF/NOTICE*")
        }
        
        manifest {
            attributes(mapOf(
                "Implementation-Title" to "jackson-databind-jsonc (All-in-One)",
                "Implementation-Version" to project.version,
                "Multi-Release" to "true"
            ))
        }
    }
    
    // All-in-One JAR（エンタープライズ環境向け）- shadowJar互換性のため残す
    val shadowJar = register<Jar>("shadowJar") {
        archiveClassifier.set("shadow")
        archiveFileName.set("jackson-databind-jsonc-${project.version}-shadow.jar")
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        
        from(sourceSets.main.get().output)
        
        // Jackson関連のみ含める（Guava, Commons-Mathは除外）
        from({
            configurations.runtimeClasspath.get()
                .filter { it.name.contains("jackson") && it.name.endsWith("jar") }
                .map { zipTree(it) }
        }) {
            exclude("META-INF/*.SF")
            exclude("META-INF/*.DSA")
            exclude("META-INF/*.RSA")
            exclude("META-INF/DEPENDENCIES")
            exclude("META-INF/LICENSE*")
            exclude("META-INF/NOTICE*")
        }
        
        manifest {
            attributes(mapOf(
                "Implementation-Title" to "jackson-databind-jsonc (All-in-One)",
                "Implementation-Version" to project.version,
                "Multi-Release" to "true"
            ))
        }
    }
    
    // 両方をビルド
    build {
        dependsOn(fatJar)
        dependsOn(shadowJar)
    }
    
    named<Test>("test") {
        useJUnitPlatform()
    }

    // Configure Javadoc: UTF-8 and enable doclint (except missing for internal/private)
    withType<Javadoc> {
    (options as StandardJavadocDocletOptions).apply {
            encoding = "UTF-8"
            charSet = "UTF-8"
            docEncoding = "UTF-8"
            // Report most issues; allow missing for non-public elements to reduce noise
            addStringOption("Xdoclint:all,-missing", "-quiet")
            // Link to Java SE API docs (avoid redirects)
            links("https://docs.oracle.com/en/java/javase/21/docs/api/")
        }
    }
}

// Use --release 8 to generate Java 8 compatible bytecode without deprecated source/target flags
tasks.withType<JavaCompile>().configureEach {
    options.encoding = "UTF-8"
    // Clear legacy source/target set by defaults and use release flag
    options.release.set(8)
}

// Publishing configuration
// Artifacts are built here; publishing to Maven Central is handled by the root-level
// Gradle Nexus Publish configuration (OSSRH: s01.oss.sonatype.org) and GitHub Actions.

// GPG Signing Configuration
// Maven Central requires signed artifacts; CI uses in-memory keys via env vars.
// Vanniktech plugin handles signing via ORG_GRADLE_PROJECT_signingInMemoryKey/Password
// This block provides fallback support for legacy GPG_* environment variables
signing {
    // Support multiple environment variable naming conventions
    // Priority: ORG_GRADLE_PROJECT_* > GPG_* > SIGNING_*
    var signingKey = System.getenv("ORG_GRADLE_PROJECT_signingInMemoryKey") 
        ?: System.getenv("GPG_PRIVATE_KEY") 
        ?: System.getenv("SIGNING_SECRET_KEY")
    val signingPassword = System.getenv("ORG_GRADLE_PROJECT_signingInMemoryKeyPassword")
        ?: System.getenv("GPG_PASSPHRASE") 
        ?: System.getenv("SIGNING_PASSWORD")
    val hasSigningCredentials = !signingKey.isNullOrEmpty() && !signingPassword.isNullOrEmpty()
    
    if (hasSigningCredentials && signingKey != null) {
        // Transform key if needed
        var transformedKey = signingKey
        
        // 1. Convert escaped newlines (\n as string literal) to actual newlines
        if (transformedKey.contains("\\n")) {
            transformedKey = transformedKey.replace("\\n", "\n")
            println("GPG key: Converted escaped newlines to actual newlines")
        }
        
        // 2. Detect and decode Base64-encoded keys
        // Base64 keys typically don't contain the ASCII armor header
        if (!transformedKey.contains("-----BEGIN PGP PRIVATE KEY BLOCK-----")) {
            try {
                // Attempt Base64 decode
                val decoder = Base64.getDecoder()
                val decoded = decoder.decode(transformedKey.replace("\n", "").replace("\r", ""))
                transformedKey = decoded.toString(Charsets.UTF_8)
                println("GPG key: Decoded from Base64 format")
            } catch (e: IllegalArgumentException) {
                // Not Base64, might already be ASCII-armored but without proper newlines
                println("GPG key: Not Base64 encoded, using as-is")
            }
        }
        
        // 3. Validate ASCII-armored format and configure signing
        if (transformedKey.contains("-----BEGIN PGP PRIVATE KEY BLOCK-----")) {
            try {
                useInMemoryPgpKeys(transformedKey, signingPassword)
                println("✓ GPG signing configured successfully")
            } catch (e: Exception) {
                println("⚠ Failed to configure GPG signing: ${e.message}")
                println("  Vanniktech plugin will attempt signing with ORG_GRADLE_PROJECT_* variables")
            }
        } else {
            println("⚠ GPG key does not appear to be in ASCII-armored format")
            println("  Expected format: -----BEGIN PGP PRIVATE KEY BLOCK-----")
            println("  Vanniktech plugin will attempt signing with ORG_GRADLE_PROJECT_* variables")
        }
    } else {
        println("GPG signing credentials not found - artifacts will be unsigned")
        println("Set ORG_GRADLE_PROJECT_signingInMemoryKey/Password or GPG_PRIVATE_KEY/GPG_PASSPHRASE for signing")
    }
}

// Additional publication for fatJar artifact
// Vanniktech handles the main 'maven' publication, we add fatJar as extra
publishing {
    publications {
        create<MavenPublication>("fatJar") {
            artifact(tasks.named("fatJar").get())
            artifactId = "jackson-databind-jsonc-all"
            
            pom {
                name.set("Jackson Databind JSONC (All-in-One)")
                description.set("JSONC (JSON with Comments) support for Jackson - All-in-One JAR with dependencies")
                url.set("https://github.com/vemikrs/jackson-databind-jsonc")
                
                licenses {
                    license {
                        name.set("Apache License 2.0")
                        url.set("https://www.apache.org/licenses/LICENSE-2.0")
                    }
                }
                
                developers {
                    developer {
                        id.set("vemikrs")
                        name.set("vemikrs")
                    }
                }
                
                scm {
                    connection.set("scm:git:git://github.com/vemikrs/jackson-databind-jsonc.git")
                    developerConnection.set("scm:git:ssh://github.com:vemikrs/jackson-databind-jsonc.git")
                    url.set("https://github.com/vemikrs/jackson-databind-jsonc")
                }
            }
        }
    }
}
